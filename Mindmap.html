<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mind Map App</title>

<style>
html, body {
  margin: 0;
  height: 100%;
  overflow: hidden;
  font-family: Arial, sans-serif;
  background: #f4f6f8;
}

#toolbar {
  background: #222;
  color: white;
  padding: 8px;
  display: flex;
  justify-content: space-between; /* key line */
  align-items: center;
}
#toolbar-left{
  display: flex;
  justify-content: flex-start;
  gap: 8px;
}
#toolbar-right {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}

#colorPalette {
  display: flex;
  flex-wrap: wrap;
}

button, select {
  padding: 5px 8px;
}
input {
  vertical-align:middle;
  padding: 0px 1px;
}
#viewport {
  width: 100%;
  height: calc(100% - 42px);
  overflow: hidden;
}

#viewport, .node {
  user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

#world {
  position: relative;
  width: 5000px;
  height: 5000px;
  transform-origin: 0 0;
}

#canvas {
  position: relative;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  transform-origin: 0 0;
}

.node {
  position: absolute;
  background: transparent;
  box-shadow: none;
  border-radius: 0;
  padding: 8px 10px;
  min-width: unset;
  max-width: 350px;
  min-height: 30px;
  font-size: x-large;
  font-weight: bold;
  text-align: center;
  vertical-align: bottom;
  line-height: 1.4;
  cursor: move;
  text-wrap: wrap;
  inline-size: 90%;
  overflow-wrap: break-word;
}

.node-ref {
  margin-left: 6px;
}

.ref-link {
  text-decoration: none;
  font-size: 0.9em;
  opacity: 0.6;
}

.ref-link:hover {
  opacity: 1;
}

.node.selected {
  background: rgba(0, 123, 255, 0.08);
}

.node.collapsed {
  opacity: 0.75;
  border-style: dashed;
}

svg {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  transform-origin: 0 0;
  overflow: visible;
  pointer-events: none;
  z-index: 10;
}

#inspector {
  position: absolute;
  right: 0;
  top: 48px;
  width: 260px;
  height: calc(100% - 42px);
  background: #f8f9fa;
  border-left: 1px solid #ddd;
  padding: 12px;
  box-sizing: border-box;
  font-size: 14px;
}

#inspector textarea {
  width: 100%;
  margin-bottom: 10px;
}

#inspector input {
  width: 100%;
  margin-bottom: 10px;
}

#viewport {
  width: calc(100% - 260px);
}


</style>
</head>

<body>
<div id="inspector">
  <h3>Node Editor</h3>

  <label>Label</label>
  <textarea id="editText" rows="4"></textarea>

  <label>Reference URL</label>
  <input type="text" id="editURL">

  <label>Text Color</label>
  <div id="colorPalette"></div>

</div>

<div id="toolbar">
  <div id="toolbar-left">
    <button onclick="exportPNG()">Export PNG</button>
    <button onclick="exportSVG()">Export SVG</button>
    <button onclick="exportJSON()">Export JSON</button>
    <button onclick="importJSON()">Import JSON</button>
    <button onclick="fitToWindow()">Fit to Window</button>
    <button onclick="horizontalTreeLayout()">Adjust Layout</button>
    <button onclick="removeLastConnection()">Remove last connection</button>
    <input type="color" id="lineColor">
  </div>

  <div id="toolbar-right">
    <button onclick="loadFromCache()">Reload Cached</button>
    <button onclick="clearCache()">New Map</button>

  </div>
</div>

<div id="viewport">
    <div id="world">
    <div id="canvas"></div>
    <svg id="lines"></svg>
    </div>
  </div>




<script>
const canvas = document.getElementById("canvas");
let svg = document.getElementById("lines");
const viewport = document.getElementById("viewport");

const paletteColors = [
  "#000000",
  "#1f77b4",
  "#2ca02c",
  "#d62728",
  "#9467bd",
  "#ff7f0e",
  "#17becf",
  "#e377c2",
  "#7f7f7f"
];

let nodes = [];
let edges = [];
let primaryNode = null;
let selectedNodes = new Set();
let draggingNode = null;
let offsetX, offsetY;

let scale = 1;
let panX = 0;
let panY = 0;

const palette = document.getElementById("colorPalette");
paletteColors.forEach(color => {
  const swatch = document.createElement("div");
  swatch.style.width = "22px";
  swatch.style.height = "22px";
  swatch.style.borderRadius = "50%";
  swatch.style.background = color;
  swatch.style.cursor = "pointer";
  swatch.style.display = "inline-block";
  swatch.style.margin = "4px";
  swatch.style.border = "2px solid transparent";

  swatch.addEventListener("click", () => {
    applyColorToSelection(color);
  });

  palette.appendChild(swatch);
});

function applyColorToSelection(color) {
  if (selectedNodes.size === 0) return;

  selectedNodes.forEach(node => {
    node.color = color;
    node.el.style.color = color;
  });

  resetTransform();
  redraw();
  applyTransform();
}

/* ---------- CACHING ---------- */
function saveToCache() {
  clearSelection(); // remove outline
  const data = {
    nodes: nodes.map((n, idx) => ({
      id: idx,
      text: n.text.trim(),
      url: n.url.trim(),
      x: parseFloat(n.el.style.left),
      y: parseFloat(n.el.style.top),
      className: n.el.className,
      color: n.color
    })),
    edges: edges.map(e => ({
      from: nodes.indexOf(e.from),
      to: nodes.indexOf(e.to),
    })),
    view: {
      scale: scale,
      panX: panX,
      panY: panY
    }
  };

  localStorage.setItem("mindmap-autosave", JSON.stringify(data));
}

function loadFromCache() {
  const saved = localStorage.getItem("mindmap-autosave");
  if (!saved) {
    //alert("No cached version found.");
    return;
  }

  const data = JSON.parse(saved);
  loadJSON(data);

  // Restore zoom & pan
  if (data.view) {
    scale = data.view.scale || 1;
    panX = data.view.panX || 0;
    panY = data.view.panY || 0;
    applyTransform();
  }
}

function clearCache() {
  localStorage.removeItem("mindmap-autosave");
  location.replace(location)

}


function setNodeReference(node, url) {
  const refSpan = node.querySelector(".node-ref");

  if (!url) {
    refSpan.innerHTML = "";
    return;
  }

  refSpan.innerHTML = `
    <a href="${url}" target="_blank" class="ref-link">ðŸ”—</a>
  `;
}

let el = document.getElementById('lineColor');
el.setAttribute("value", rgbToHex("rgba(163,163,163,1)"))
el.addEventListener('input', function() {  // I tried also onchange
  resetTransform();
  redraw();
  applyTransform();
});

function generateId() {
  return crypto.randomUUID(); // modern browsers
}
/* ---------- NODE ---------- */
function createNode(x, y, text="New Node", url="", className="node", color="#000000") {
  text = text.trim();
  id = generateId()
  const node = {
    id,
    text,
    url,
    x,
    y,
    color,
    className
  };

  nodes.push(node);
  renderNode(node);
}

function renderNode(node) {
  // Append a node object to node
  const nodeObj = document.createElement("div");
  nodeObj.className = node.className;
  nodeObj.className = nodeObj.className.replace("selected","");
  nodeObj.className = nodeObj.className.replace("collapsed",""); 
  nodeObj.style.left = node.x + "px";
  nodeObj.style.top = node.y + "px";
  nodeObj.style.color = node.color || "#000000";

  nodeObj.id = node.id;

  // Render HTML here
  nodeObj.innerHTML = `
    <span class="node-text">${node.text}</span>
    ${
      node.url
        ? `<a href="${node.url}" target="_blank" class="ref-link">ðŸ”—</a>`
        : ""
    }
  `;
  
  canvas.appendChild(nodeObj);
  node.el = nodeObj;
  attachNodeEvents(node);

}

function edgeExists(fromNode, toNode) {
  return edges.some(e => e.from === fromNode && e.to === toNode);
}


function attachNodeEvents(node) {
  // --- Drag ---
  node.el.addEventListener("mousedown", e => {
    if (e.target.tagName === "A") return;
    draggingNode = node.el;
    offsetX = e.offsetX;
    offsetY = e.offsetY;
    e.stopPropagation();
  });

  node.el.addEventListener("contextmenu", e => {
    e.preventDefault(); // disable browser menu
    toggleSubtree(node);
  });

  // --- Select / Connect ---
node.el.addEventListener("click", e => {
  e.stopPropagation();

  const multi = e.ctrlKey || e.metaKey;

  // If multi-select key pressed â†’ only select
  if (multi) {
    selectNode(node.el, true);
    return;
  }

  const clickedNode = refnodeObj(node.el);

  // If nothing selected yet â†’ select only
  if (selectedNodes.size === 0) {
    selectNode(node.el, false);
    // âœ¨ Focus text editor immediately
    editText.focus();
    editText.select();   // optional: auto-select placeholder text
    return;
  }

  // If clicking same primary â†’ clear selection
  if (primaryNode === clickedNode) {
    clearSelection();
    return;
  }

  // CONNECT from primary to clicked
  if (primaryNode && !edgeExists(primaryNode, clickedNode)) {
    edges.push({
      from: primaryNode,
      to: clickedNode
    });

    resetTransform();
    redraw();
    applyTransform();
    saveToCache();
  }

  clearSelection();
});
  // --- Edit ---
}

function rgbToHex(rgb) {
  const result = rgb.match(/\d+/g);
  if (!result) return "#f4f6f8";
  return "#" + result
    .slice(0, 3)
    .map(x => (+x).toString(16).padStart(2, '0'))
    .join('');
}

function refnodeObj(nodeObj){
  refnodes = nodes.filter(n => n.el.id  === nodeObj.id )  
  if (!refnodes){ return ;}
  return refnodes[0]
}

const editText = document.getElementById("editText");
const editURL = document.getElementById("editURL");
editText.addEventListener("input", () => {
  if (selectedNodes.size !== 1) return;

  selectedNodes.forEach(node => {
    node.text = editText.value;
    const textSpan = node.el.querySelector(".node-text");
    if (textSpan) textSpan.textContent = node.text;
  });
});

editURL.addEventListener("input", () => {
  if (selectedNodes.size !== 1) return;

  selectedNodes.forEach(node => {
    node.url = editURL.value;

    // Remove old link
    const oldLink = node.el.querySelector(".ref-link");
    if (oldLink) oldLink.remove();

    // Add new link if URL exists
    if (node.url.trim() !== "") {
      const link = document.createElement("a");
      link.href = node.url;
      link.target = "_blank";
      link.className = "ref-link";
      link.textContent = "ðŸ”—";
      node.el.appendChild(link);
    }
  });

});


function updateInspector() {
  if (selectedNodes.size !== 1) {
    editText.value = "";
    editURL.value = "";
    return;
  }

  const first = [...selectedNodes][0];

  editText.value = first.text || "";
  editURL.value = first.url || "";
}



function selectNode(nodeObj, multi = false) {
  const node = refnodeObj(nodeObj);
  if (!node) return;

  if (!multi) {
    clearSelection();
  }

  if (selectedNodes.has(node)) {
    selectedNodes.delete(node);
    node.el.classList.remove("selected");
  } else {
    selectedNodes.add(node);
    node.el.classList.add("selected");
  }

  // The last clicked node becomes primary
  primaryNode = node;

  updateInspector();
}


function clearSelection() {
  nodes.forEach(n => n.el.classList.remove("selected"));
  selectedNodes.clear();
  primaryNode = null
}


function applyChanges() {
  if (selectedNodes.size === 0) return;

  const newText = document.getElementById("editText").value.trim();
  const newURL = document.getElementById("editURL").value.trim();

  selectedNodes.forEach(node => {
    node.text = newText || node.text;
    node.url = newURL || node.url;
    node.color = node.color;

    node.el.style.color = newColor;
    node.el.querySelector(".node-text").textContent = node.text;
  });

  resetTransform()
  redraw();
  applyTransform()
  saveToCache();
}


function getRoots(){
  if (nodes.length === 0) return;
  const children = new Map();
  const indegree = new Map();
  const subtree = new Map();

  nodes.forEach(n => {
    if (n.el.style.display === "none") return;
    children.set(n, []);
    indegree.set(n, 0);
  });

  edges.forEach(e => {
    if (
    e.from.el.style.display === "none" ||
    e.to.el.style.display === "none"
    ) {return;}
    else{
    children.get(e.from)?.push(e.to);
    indegree.set(e.to, indegree.get(e.to) + 1);
    }});

  // Sort children alphabetically by text
  children.forEach((kids, parent) => {
    kids.sort((a, b) =>
      a.text.localeCompare(b.text)
    );
  });

  const roots = nodes.filter(n => indegree.get(n) === 0);
  return roots
}

/* ---------- DRAW LINES ---------- */
function redraw() {
  svg.innerHTML = "";

  const canvasRect = canvas.getBoundingClientRect();

  edges.forEach(e => {
    const a = nodes.find(n => n === e.from);
    const b = nodes.find(n => n === e.to);

    if (a.el.style.display === "none"  || b.el.style.display === "none" ) return;

    const aRect = a.el.getBoundingClientRect();
    const bRect = b.el.getBoundingClientRect();


    // Source: right center
    const x0 = aRect.left - canvasRect.left;
    const x1 = aRect.right - canvasRect.left;
    const y1 = aRect.bottom - canvasRect.top;


    // Target: left center
    const x2 = bRect.right - canvasRect.left;
    const y2 = bRect.bottom - canvasRect.top;

    if (
      [x1, y1, x2, y2].some(v => Number.isNaN(v))
    ) return;

    const dx = Math.max(30, (x2 - x1) * 0.5);

    const path = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );


    path.setAttribute(
      "d",
      `M ${x0} ${y1}
      L ${x1} ${y1}
      L ${x1} ${y2}
      L ${x2} ${y2}`
    );

    path.setAttribute("fill", "none");
    path.setAttribute("stroke", el.value || "#555");
    path.setAttribute("stroke-width", "4");

    svg.appendChild(path);
  });
}


/* ---------- DRAG ---------- */
document.addEventListener("mousemove", e => {
  if (!draggingNode) return;

  const worldRect = world.getBoundingClientRect();

  const x = (e.clientX - worldRect.left - offsetX * scale) / scale;
  const y = (e.clientY - worldRect.top - offsetY * scale) / scale;

  draggingNode.x = x;
  draggingNode.y = y;
  draggingNode.style.left = x + "px";
  draggingNode.style.top  = y + "px";

  resetTransform()
  redraw();
  applyTransform()
});

document.addEventListener("mouseup", () => {
  draggingNode = null;
  if (!panning) return;
});

/* ---------- EMPTY CLICK ONLY ---------- */
canvas.addEventListener("dblclick", e => {
  if (e.target !== canvas) return;

  const x = (e.clientX - panX) / scale;
  const y = (e.clientY - panY) / scale;

  createNode(x, y);

  const newNode = nodes[nodes.length - 1];

  selectNode(newNode.el);

  // âœ¨ Focus text editor immediately
  editText.focus();
  editText.select();   // optional: auto-select placeholder text
});


/* ---------- ZOOM ---------- */
viewport.addEventListener("wheel", e => {
  e.preventDefault();
  scale += e.deltaY * -0.001;
  scale = Math.min(Math.max(.3, scale), 3);
  applyTransform();
});

/* ---------- PAN ---------- */
let panning = false;

viewport.addEventListener("mousedown", e => {
  panning = true;
  viewport.style.cursor = "grabbing";
  offsetX = e.clientX - panX;
  offsetY = e.clientY - panY;
});

viewport.addEventListener("click", e => {
  clearSelection()
});

document.addEventListener("mousemove", e => {
  if (!panning) return;
  panX = e.clientX - offsetX;
  panY = e.clientY - offsetY;
  applyTransform();
});

document.addEventListener("mouseup", () => {
  panning = false;
  viewport.style.cursor = "grab";
});

function resetTransform() {
  world.style.transform =
    `translate(${0}px, ${0}px) scale(${1})`;
}

function applyTransform() {
  world.style.transform =
    `translate(${panX}px, ${panY}px) scale(${scale})`;
}


/* ---------- KEYBOARD ---------- */
document.addEventListener("keydown", e => {
  if (e.key === "Delete" && selectedNodes) {
    selectedNodes.forEach(selNode => {
    nodes = nodes.filter(n => n !== selNode);
    edges = edges.filter(e => e.from !== selNode && e.to !== selNode);
    selNode.el.remove()
    })

    clearSelection();
  resetTransform()
  redraw();
  applyTransform()
  }
  // âŽ‹ ESC clears selection
  if (e.key === "Escape") {
    clearSelection();
    updateInspector();
  }
});


function getChildren(node) {
  return edges
    .filter(e => e.from === node)
    .map(e => e.to);
}

function toggleSubtree(node) {
  const collapsed = node.el.dataset.collapsed === "true";
  node.el.dataset.collapsed = collapsed ? "false" : "true";

  if (node.el.dataset.collapsed === "true") {
    hideSubtree(node);
    node.el.classList.add("collapsed");
  } else {
    showSubtree(node);
    node.el.classList.remove("collapsed");
  }

  horizontalTreeLayout();


}

function hideSubtree(node) {
  getChildren(node).forEach(child => {
    child.el.style.display = "none";
    child.el.dataset.hiddenByParent = "true";
    hideSubtree(child);
  });
  horizontalTreeLayout();
}

function showSubtree(node) {
  getChildren(node).forEach(child => {
    if (node.el.dataset.collapsed !== "true"){
      if (child.el.dataset.collapsed !== "true") {
        child.el.style.display = "block";
        child.el.dataset.hiddenByParent = "false";
        showSubtree(child);
      }
    else {
      child.el.style.display = "block";
      child.el.dataset.hiddenByParent = "false";
    }}
  });
  horizontalTreeLayout();

}


/* ---------- EXPORT PNG ---------- */
function exportPNG() {
  if (nodes.length === 0) return;

  clearSelection();

  const padding = 40;

  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;

  nodes.forEach(n => {
    if (n.el.style.display === "none") return;

    const x = parseFloat(n.el.style.left);
    const y = parseFloat(n.el.style.top);
    const w = n.el.offsetWidth;
    const h = n.el.offsetHeight;

    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + w);
    maxY = Math.max(maxY, y + h);
  });

  const width = maxX - minX + padding * 2;
  const height = maxY - minY + padding * 2;

  html2canvas(world, {
    backgroundColor: "#ffffff",
    x: minX - padding,
    y: minY - padding,
    width: width,
    height: height,
    scale: 2 // higher resolution
  }).then(canvasExport => {
    const link = document.createElement("a");
    link.download = "mindmap.png";
    link.href = canvasExport.toDataURL("image/png");
    link.click();
  });
}


/* ---------- EXPORT SVG ---------- */
function exportSVG() {
  const padding = 40;

  // Get bounds of all nodes
  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;
  clearSelection(); // remove outline
  nodes.forEach(n => {
    const x = parseFloat(n.el.style.left);
    const y = parseFloat(n.el.style.top);
    const w = n.el.offsetWidth;
    const h = n.el.offsetHeight;

    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + w);
    maxY = Math.max(maxY, y + h);
  });

  const width = maxX - minX + padding * 2;
  const height = maxY - minY + padding * 2;

  const xmlns = "http://www.w3.org/2000/svg";
  const svgExport = document.createElementNS(xmlns, "svg");

  svgExport.setAttribute("xmlns", xmlns);
  svgExport.setAttribute("width", width);
  svgExport.setAttribute("height", height);
  svgExport.setAttribute("viewBox", `0 0 ${width} ${height}`);

  /* ---------- DRAW EDGES ---------- */
  edges.forEach(e => {
    const a = nodes.find(n => n === e.from);
    const b = nodes.find(n => n === e.to);

    if (a.el.style.display === "none"  || b.el.style.display === "none" ) return;

    const ox = parseFloat(a.el.style.left) - minX + padding;
    const ax = parseFloat(a.el.style.left) + a.el.offsetWidth - minX + padding;
    const ay = parseFloat(a.el.style.top) + a.el.offsetHeight - minY;

    const bx = parseFloat(b.el.style.left) + b.el.offsetWidth - minX + padding;
    const by = parseFloat(b.el.style.top) + b.el.offsetHeight - minY;

    const dx = Math.max(50, (bx - ax) * 0.5);

    const path = document.createElementNS(xmlns, "path");
    path.setAttribute(
      "d",
      `M ${ox} ${ay}
      L ${ax} ${ay}
      L ${ax} ${by}
      L ${bx} ${by}`
    );

    path.setAttribute("fill", "none");
    path.setAttribute("stroke", el.value || "#555");
    path.setAttribute("stroke-width", "2");

    svgExport.appendChild(path);
  });

  /* ---------- DRAW NODES ---------- */
  nodes.forEach(n => {
    const x = parseFloat(n.el.style.left) - minX + padding;
    const y = parseFloat(n.el.style.top) - minY;
    const w = n.el.offsetWidth;
    const h = n.el.offsetHeight;

    const rect = document.createElementNS(xmlns, "rect");
    rect.setAttribute("x", x);
    rect.setAttribute("y", y);
    rect.setAttribute("width", w);
    rect.setAttribute("height", h);
    rect.setAttribute("rx", 8);
    rect.setAttribute("fill", "transparent");
    rect.setAttribute("stroke", "transparent");

    svgExport.appendChild(rect);

    const text = document.createElementNS(xmlns, "text");
    text.setAttribute("x", x + w / 2);
    text.setAttribute("y", y + h / 2);
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "middle");
    text.setAttribute("fill", n.color);
    text.setAttribute("font-family", "Arial");
    text.setAttribute("font-size", "x-large");
    text.setAttribute("font-weight", "bold");

    text.textContent = n.text;

    svgExport.appendChild(text);
  });

  /* ---------- DOWNLOAD ---------- */
  const serializer = new XMLSerializer();
  const svgBlob = new Blob(
    [serializer.serializeToString(svgExport)],
    { type: "image/svg+xml" }
  );

  const url = URL.createObjectURL(svgBlob);
  const link = document.createElement("a");
  link.href = url;
  link.download = "mindmap.svg";
  link.click();
  URL.revokeObjectURL(url);
}


/* ---------- EXPORT JSON ---------- */
function exportJSON() {
  clearSelection(); // remove outline
  const data = {
    nodes: nodes.map((n, idx) => ({
      id: idx, // unique index
      text: n.text.trim(),
      url: n.url.trim(),
      x: parseFloat(n.el.style.left),
      y: parseFloat(n.el.style.top),
      className: n.el.className,
      color: n.color
    })),
    edges: edges.map(e => ({
      from: nodes.indexOf(e.from),
      to: nodes.indexOf(e.to),
    }))

  };

  const jsonStr = JSON.stringify(data, null, 2);
  download(jsonStr, "mindmap.json");
}

function importJSON() {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = ".json";
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;

    file.text().then(text => {
      const data = JSON.parse(text);
      loadJSON(data);
    });
  };
  input.click();
}

function loadJSON(data) {
  // Clear existing
  canvas.innerHTML = ""; 
  nodes = [];
  edges = [];
  selectedNode = null;
  document.getElementById("lines").remove();

  // Recreate SVG and bind it
  const newSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  newSvg.setAttribute("id", "lines");
  world.appendChild(newSvg);
  svg = newSvg;

  // Recreate nodes
  data.nodes.forEach(n => {
    createNode(n.x, n.y, n.text, n.url, n.className, n.color);
    const created = nodes[nodes.length - 1];
    if (n.ref) {
      created.dataset.ref = n.ref;
      setNodeReference(created, n.ref);
    }
  });

  // Recreate edges using node references
  data.edges.forEach(e => {
    const fromNode = nodes[e.from];
    const toNode = nodes[e.to];
    if (fromNode && toNode) {
      edges.push({
        from: fromNode,
        to: toNode,
      });
    }
  });

  // Wait for browser to render text, then layout & redraw
  requestAnimationFrame(() => {
  resetTransform();
  redraw();
  applyTransform();
  horizontalTreeLayout();
  });
}

function download(text, file) {
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text]));
  a.download = file;
  a.click();
}

function horizontalTreeLayout() {
  if (nodes.length === 0) return;

  // ðŸ”’ Freeze transform during layout
  const prevTransform = world.style.transform;
  world.style.transform = "none";

  // Force layout flush
  nodes.forEach(n => n.el.getBoundingClientRect());

  const children = new Map();
  const indegree = new Map();
  const subtree = new Map();

  nodes.forEach(n => {
    if (n.el.style.display === "none") return;
    children.set(n, []);
    indegree.set(n, 0);
  });

  edges.forEach(e => {
    if (
    e.from.el.style.display === "none" ||
    e.to.el.style.display === "none"
    ) {return;}
    else{
    children.get(e.from)?.push(e.to);
    indegree.set(e.to, indegree.get(e.to) + 1);
    }});

  // Sort children alphabetically by text
  children.forEach((kids, parent) => {
    kids.sort((a, b) =>
      a.text.localeCompare(b.text)
    );
  });

  const roots = nodes.filter(n => indegree.get(n) === 0);

  const minlevelGap = 50;   // horizontal spacing
  const verticalGap = 50; // vertical spacing
  const maxWidth = 450;
  let levelGap = nodes.map(n => n.el.getBoundingClientRect().width).sort((a,b) => a > b);
  levelGap = Math.max(minlevelGap, Math.max(levelGap[levelGap.length - 1]));

  levelGap = Math.min(levelGap, maxWidth)

  function computeHeight(node) {
    if (subtree.has(node)) return subtree.get(node);

    const kids = children.get(node);
    const selfH = node.el.getBoundingClientRect().height;

    if (!kids || kids.length === 0) {
      subtree.set(node, selfH);
      return selfH;
    }

    let h = 0;
    kids.forEach((k, i) => {
      h += computeHeight(k);
      if (i < kids.length - 1) h += verticalGap;
    });

    h = Math.max(h, selfH);
    subtree.set(node, h);
    return h;
  }

  roots.forEach(r => computeHeight(r));

  let cursorY = 100;

  function place(node, depth, topY) {
    const kids = children.get(node);
    const nodeH = node.el.getBoundingClientRect().height;

    let centerY;

    if (!kids || kids.length === 0) {
      // Leaf node
      centerY = topY - nodeH / 2;
    } else {
      // Place children first
      let y = topY;
      const childCenters = [];

      kids.forEach(k => {
        place(k, depth + 1, y);
        const childTop = parseFloat(k.el.style.top);
        const childH = k.el.getBoundingClientRect().height;
        childCenters.push(childTop + childH / 2);

        y += subtree.get(k) + verticalGap;
      });
      // Parent centered exactly between first & last child center
      const firstCenter = childCenters[0];
      const lastCenter = childCenters[childCenters.length - 1];
      if (firstCenter === lastCenter){
        centerY = firstCenter - (nodeH - kids[0].el.getBoundingClientRect().height)/2;
      } else {
      centerY = (firstCenter + lastCenter) / 2;
      }
    }

    node.el.style.left = depth * levelGap + "px";
    node.el.style.top = centerY - nodeH / 2 + "px";

  }

  roots.forEach(r => {
    place(r, 0, cursorY);
    cursorY += subtree.get(r) + verticalGap * 2;

  });

  // ðŸ”“ Restore transform
  world.style.transform = prevTransform;

  // ðŸ”¥ Recalculate edges from new node positions
  resetTransform()
  redraw();
  applyTransform()
  saveToCache()
}

function fitToWindow() {
  if (nodes.length === 0) return;

  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;

  nodes.forEach(n => {
    if (n.el.style.display === "none") return;

    const x = parseFloat(n.el.style.left);
    const y = parseFloat(n.el.style.top);
    const w = n.el.offsetWidth;
    const h = n.el.offsetHeight;

    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + w);
    maxY = Math.max(maxY, y + h);
  });

  const worldWidth = maxX - minX;
  const worldHeight = maxY - minY;

  const viewWidth = viewport.clientWidth;
  const viewHeight = viewport.clientHeight;

  const scaleX = viewWidth / worldWidth;
  const scaleY = viewHeight / worldHeight;

  scale = Math.min(scaleX, scaleY) * 0.9; // padding

  panX = -minX * scale + (viewWidth - worldWidth * scale) / 2;
  panY = -minY * scale + (viewHeight - worldHeight * scale) / 2;

  applyTransform();
}

function removeLastConnection() {
  if (edges.length === 0) return;

  edges.pop();          // remove most recent connection
  clearSelection();     // safety
  resetTransform();
  redraw();
  applyTransform();  // horizontalTreeLayout();
  saveToCache()
}

window.addEventListener("load", () => {
  const saved = localStorage.getItem("mindmap-autosave");
  if (saved) {
    loadFromCache();
  }
});


</script>

<!-- PNG export lib -->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

</body>
</html>
