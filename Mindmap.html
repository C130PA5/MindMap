<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mind Map App</title>

<style>
html, body {
  margin: 0;
  height: 100%;
  overflow: hidden;
  font-family: Arial, sans-serif;
  background: #f4f6f8;
}

#toolbar {
  background: #222;
  color: white;
  padding: 8px;
  display: flex;
  gap: 8px;
  align-items: center;
}

button, select {
  padding: 5px 8px;
}

#viewport {
  width: 100%;
  height: calc(100% - 42px);
  overflow: hidden;
}

#viewport, .node {
  user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

#world {
  position: relative;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  transform-origin: 0 0;
}
#canvas {
  position: relative;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  transform-origin: 0 0;
}

.node {
  position: absolute;
  padding: 10px;
  min-width: 120px;
  max-width: 240px;
  word-break: break-word;
  line-height: 1.3;
  border-radius: 8px;
  background: white;
  text-align: center;
  cursor: move;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.node.selected {
  outline: 3px solid #007bff;
}

svg {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  transform-origin: 0 0;
  overflow: visible;
  pointer-events: none;
  z-index: 10;
}


/* ===== COLOR TEMPLATES ===== */

/* ML */
.theme-ml {
  background: #e3f2fd;
  color: #0d47a1;
}

/* AI */
.theme-ai {
  background: #fce4ec;
  color: #880e4f;
}

/* Data */
.theme-data {
  background: #e8f5e9;
  color: #1b5e20;
}

/* Dev / Infra */
.theme-dev {
  background: #fff3e0;
  color: #e65100;
}

/* Research */
.theme-research {
  background: #ede7f6;
  color: #4527a0;
}

/* Tooling */
.theme-tools {
  background: #e0f2f1;
  color: #004d40;
}

/* Highlight / Core */
.theme-core {
  background: #263238;
  color: #ffffff;
}

/* Warning / Experimental */
.theme-experimental {
  background: #fffde7;
  color: #827717;
}
</style>
</head>

<body>

<div id="toolbar">
  <button onclick="exportPNG()">Export PNG</button>
  <button onclick="exportSVG()">Export SVG</button>
  <button onclick="exportJSON()">Export JSON</button>
  <button onclick="importJSON()">Import JSON</button>
  <button onclick="horizontalTreeLayout()">Adjust Layout</button>
  <button onclick="removeLastConnection()">Remove last connection</button>

    <select id="category">
    <option value="">Theme</option>
    <option value="ml">ML</option>
    <option value="ai">AI</option>
    <option value="data">Data</option>
    <option value="dev">Dev / Infra</option>
    <option value="research">Research</option>
    <option value="tools">Tools</option>
    <option value="core">Core</option>
    <option value="experimental">Experimental</option>
    </select>

</div>

<div id="viewport">
    <div id="world">
    <div id="canvas"></div>
    <svg id="lines"></svg>
    </div>
</div>

<script>
const canvas = document.getElementById("canvas");
let svg = document.getElementById("lines");
const viewport = document.getElementById("viewport");
let activeTheme = "";

let nodes = [];
let edges = [];
let selectedNode = null;
let draggingNode = null;
let offsetX, offsetY;

let scale = 1;
let panX = 0;
let panY = 0;

/* ---------- World Expansion ---------- */
function expandWorldIfNeeded(x, y) {
  const padding = 500;

  const currentWidth = world.offsetWidth;
  const currentHeight = world.offsetHeight;

  if (x + padding > currentWidth) {
    world.style.width = currentWidth + 2000 + "px";
  }

  if (y + padding > currentHeight) {
    world.style.height = currentHeight + 2000 + "px";
  }
}

/* ---------- NODE ---------- */
function createNode(x, y, text = "New Node", className = "node") {
  expandWorldIfNeeded(x, y);
  const node = document.createElement("div");
  node.className = className.replace("selected","");
  if (activeTheme) {
    node.classList.add("theme-" + activeTheme);
  }
  node.textContent = text;
  node.style.left = x + "px";
  node.style.top = y + "px";

  canvas.appendChild(node);
  nodes.push(node);

  // --- Drag ---
  node.addEventListener("mousedown", e => {
    draggingNode = node;
    offsetX = e.offsetX;
    offsetY = e.offsetY;
    e.stopPropagation();
  });

  // --- Select / Connect ---
  node.addEventListener("click", e => {
    e.stopPropagation();

    if (!selectedNode) {
      selectNode(node);
      return;
    }

    if (selectedNode === node) {
      clearSelection();
      return;
    }

    // CONNECT ONLY FROM LAST SELECTED
    edges.push({ a: selectedNode, b: node });
    clearSelection();
  resetTransform()
  redraw();
  applyTransform()
  });

  // --- Edit ---
  node.addEventListener("dblclick", e => {
    e.stopPropagation();
    const txt = prompt("Edit text", node.textContent);
    if (txt) node.textContent = txt;
    requestAnimationFrame(() => {
  resetTransform()
  redraw();
  applyTransform()
      //horizontalTreeLayout();
    });
  });

  return node;
}


/* ---------- SELECTION ---------- */
function selectNode(node) {
  clearSelection();
  selectedNode = node;
  node.classList.add("selected");
}

function clearSelection() {
  if (selectedNode) selectedNode.classList.remove("selected");
  selectedNode = null;
}

/* ---------- DRAW LINES ---------- */
function redraw() {
  svg.innerHTML = "";

  const canvasRect = canvas.getBoundingClientRect();

  edges.forEach(e => {
    const aRect = e.a.getBoundingClientRect();
    const bRect = e.b.getBoundingClientRect();

    // Source: right center
    const x1 = aRect.right - canvasRect.left;
    const y1 = aRect.top + aRect.height / 2 - canvasRect.top;

    // Target: left center
    const x2 = bRect.left - canvasRect.left;
    const y2 = bRect.top + bRect.height / 2 - canvasRect.top;

    if (
      [x1, y1, x2, y2].some(v => Number.isNaN(v))
    ) return;

    const dx = Math.max(80, (x2 - x1) * 0.5);

    const path = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );

    path.setAttribute(
      "d",
      `M ${x1} ${y1}
       C ${x1 + dx} ${y1},
         ${x2 - dx} ${y2},
         ${x2} ${y2}`
    );

    path.setAttribute("fill", "none");
    path.setAttribute("stroke", "#555");
    path.setAttribute("stroke-width", "2");

    svg.appendChild(path);
  });
}


/* ---------- DRAG ---------- */
document.addEventListener("mousemove", e => {
  if (!draggingNode) return;

  const worldRect = world.getBoundingClientRect();

  const x = (e.clientX - worldRect.left - offsetX * scale) / scale;
  const y = (e.clientY - worldRect.top - offsetY * scale) / scale;

  draggingNode.style.left = x + "px";
  draggingNode.style.top  = y + "px";

  resetTransform()
  redraw();
  applyTransform()
});

document.addEventListener("mouseup", () => draggingNode = null);

/* ---------- EMPTY CLICK ONLY ---------- */
canvas.addEventListener("dblclick", e => {
  if (e.target !== canvas) return;

  const worldRect = world.getBoundingClientRect();

  // Convert screen â†’ world coordinates
  const x = (e.clientX - panX) / scale;
  const y = (e.clientY - panY) / scale;


  createNode(x, y);
});

/* ---------- ZOOM ---------- */
viewport.addEventListener("wheel", e => {
  e.preventDefault();
  scale += e.deltaY * -0.001;
  scale = Math.min(Math.max(.3, scale), 3);
  applyTransform();
});

/* ---------- PAN ---------- */
let panning = false;

viewport.addEventListener("mousedown", e => {
  panning = true;
  viewport.style.cursor = "grabbing";
  offsetX = e.clientX - panX;
  offsetY = e.clientY - panY;
});

viewport.addEventListener("click", e => {
  clearSelection()
});

document.addEventListener("mousemove", e => {
  if (!panning) return;
  panX = e.clientX - offsetX;
  panY = e.clientY - offsetY;
  applyTransform();
});

document.addEventListener("mouseup", () => {
  panning = false;
  viewport.style.cursor = "grab";
});

function resetTransform() {
  world.style.transform =
    `translate(${0}px, ${0}px) scale(${1})`;
}

function applyTransform() {
  world.style.transform =
    `translate(${panX}px, ${panY}px) scale(${scale})`;
}

/* ---------- CATEGORIES ---------- */
document.getElementById("category").addEventListener("change", e => {
  activeTheme = e.target.value;

  // If a node is selected, apply immediately to it too
  if (selectedNode) {
    selectedNode.className = "node";
    if (activeTheme) {
      selectedNode.classList.add("theme-" + activeTheme);
    }
  }
});



/* ---------- KEYBOARD ---------- */
document.addEventListener("keydown", e => {
  if (e.key === "Delete" && selectedNode) {
    nodes = nodes.filter(n => n !== selectedNode);
    edges = edges.filter(e => e.a !== selectedNode && e.b !== selectedNode);
    selectedNode.remove();
    clearSelection();
  resetTransform()
  redraw();
  applyTransform()
  }
});

/* ---------- EXPORT PNG ---------- */
function exportPNG() {
  clearSelection(); // remove outline
  html2canvas(world).then(c => {
    const link = document.createElement("a");
    link.download = "mindmap.png";
    link.href = c.toDataURL();
    link.click();
  });
}

/* ---------- EXPORT SVG ---------- */
function exportSVG() {
  const padding = 40;

  // Get bounds of all nodes
  let minX = Infinity, minY = Infinity;
  let maxX = -Infinity, maxY = -Infinity;
  clearSelection(); // remove outline
  nodes.forEach(n => {
    const x = parseFloat(n.style.left);
    const y = parseFloat(n.style.top);
    const w = n.offsetWidth;
    const h = n.offsetHeight;

    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + w);
    maxY = Math.max(maxY, y + h);
  });

  const width = maxX - minX + padding * 2;
  const height = maxY - minY + padding * 2;

  const xmlns = "http://www.w3.org/2000/svg";
  const svgExport = document.createElementNS(xmlns, "svg");

  svgExport.setAttribute("xmlns", xmlns);
  svgExport.setAttribute("width", width);
  svgExport.setAttribute("height", height);
  svgExport.setAttribute("viewBox", `0 0 ${width} ${height}`);

  /* ---------- DRAW EDGES ---------- */
  edges.forEach(e => {
    const ax = parseFloat(e.a.style.left) - minX + padding + e.a.offsetWidth;
    const ay = parseFloat(e.a.style.top) - minY + padding + e.a.offsetHeight / 2;

    const bx = parseFloat(e.b.style.left) - minX + padding;
    const by = parseFloat(e.b.style.top) - minY + padding + e.b.offsetHeight / 2;

    const dx = Math.max(80, (bx - ax) * 0.5);

    const path = document.createElementNS(xmlns, "path");
    path.setAttribute(
      "d",
      `M ${ax} ${ay}
       C ${ax + dx} ${ay},
         ${bx - dx} ${by},
         ${bx} ${by}`
    );

    path.setAttribute("fill", "none");
    path.setAttribute("stroke", "#555");
    path.setAttribute("stroke-width", "2");

    svgExport.appendChild(path);
  });

  /* ---------- DRAW NODES ---------- */
  nodes.forEach(n => {
    const x = parseFloat(n.style.left) - minX + padding;
    const y = parseFloat(n.style.top) - minY + padding;
    const w = n.offsetWidth;
    const h = n.offsetHeight;

    // Get computed styles (so themes export correctly)
    const styles = getComputedStyle(n);

    const rect = document.createElementNS(xmlns, "rect");
    rect.setAttribute("x", x);
    rect.setAttribute("y", y);
    rect.setAttribute("width", w);
    rect.setAttribute("height", h);
    rect.setAttribute("rx", 8);
    rect.setAttribute("fill", styles.backgroundColor);
    rect.setAttribute("stroke", "rgba(0,0,0,0.15)");

    svgExport.appendChild(rect);

    const text = document.createElementNS(xmlns, "text");
    text.setAttribute("x", x + w / 2);
    text.setAttribute("y", y + h / 2);
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "middle");
    text.setAttribute("fill", styles.color);
    text.setAttribute("font-family", "Arial");
    text.setAttribute("font-size", "14");

    text.textContent = n.textContent;

    svgExport.appendChild(text);
  });

  /* ---------- DOWNLOAD ---------- */
  const serializer = new XMLSerializer();
  const svgBlob = new Blob(
    [serializer.serializeToString(svgExport)],
    { type: "image/svg+xml" }
  );

  const url = URL.createObjectURL(svgBlob);
  const link = document.createElement("a");
  link.href = url;
  link.download = "mindmap.svg";
  link.click();
  URL.revokeObjectURL(url);
}


/* ---------- EXPORT JSON ---------- */
function exportJSON() {
  clearSelection(); // remove outline
  const data = {
    nodes: nodes.map((n, idx) => ({
      id: idx,           // unique index
      text: n.textContent,
      x: parseFloat(n.style.left),
      y: parseFloat(n.style.top),
      className: n.className
    })),
    edges: edges.map(e => ({
      from: nodes.indexOf(e.a),
      to: nodes.indexOf(e.b)
    }))
  };

  const jsonStr = JSON.stringify(data, null, 2);
  download(jsonStr, "mindmap.json");
}

function importJSON() {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = ".json";
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;

    file.text().then(text => {
      const data = JSON.parse(text);
      loadJSON(data);
    });
  };
  input.click();
}

function loadJSON(data) {
  // Clear existing
  canvas.innerHTML = ""; 
  nodes = [];
  edges = [];
  selectedNode = null;
  document.getElementById("lines").remove();

  // Recreate SVG and bind it
  const newSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  newSvg.setAttribute("id", "lines");
  world.appendChild(newSvg);
  svg = newSvg;

  // Recreate nodes
  data.nodes.forEach(n => {
    createNode(n.x, n.y, n.text ,n.className);
  });

  // Recreate edges using node references
  data.edges.forEach(e => {
    const fromNode = nodes[e.from];
    const toNode = nodes[e.to];
    if (fromNode && toNode) {
      edges.push({ a: fromNode, b: toNode });
  resetTransform()
  redraw();
  applyTransform()
  clearSelection(); // remove outline
    }
  });

  // Wait for browser to render text, then layout & redraw
  requestAnimationFrame(() => {
  resetTransform()
  redraw();
  applyTransform()
    horizontalTreeLayout();
  });
}

function download(text, file) {
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([text]));
  a.download = file;
  a.click();
}

function horizontalTreeLayout() {
  if (nodes.length === 0) return;

  // ðŸ”’ Freeze transform during layout
  const prevTransform = world.style.transform;
  world.style.transform = "none";

  // Force layout flush
  nodes.forEach(n => n.getBoundingClientRect());

  const children = new Map();
  const indegree = new Map();
  const subtree = new Map();

  nodes.forEach(n => {
    children.set(n, []);
    indegree.set(n, 0);
  });

  edges.forEach(e => {
    children.get(e.a)?.push(e.b);
    indegree.set(e.b, indegree.get(e.b) + 1);
  });

  const roots = nodes.filter(n => indegree.get(n) === 0);

  const levelGap = 300;
  const verticalGap = 60;

  function computeHeight(node) {
    if (subtree.has(node)) return subtree.get(node);

    const kids = children.get(node);
    const selfH = node.getBoundingClientRect().height;

    if (!kids || kids.length === 0) {
      subtree.set(node, selfH);
      return selfH;
    }

    let h = 0;
    kids.forEach((k, i) => {
      h += computeHeight(k);
      if (i < kids.length - 1) h += verticalGap;
    });

    h = Math.max(h, selfH);
    subtree.set(node, h);
    return h;
  }

  roots.forEach(r => computeHeight(r));

  let cursorY = 100;

  function place(node, depth, topY) {
    const kids = children.get(node);
    const nodeRect = node.getBoundingClientRect();
    const nodeH = nodeRect.height;

    let centerY;

    if (!kids || kids.length === 0) {
      centerY = topY + nodeH / 2;
    } else {
      let y = topY;
      kids.forEach(k => {
        place(k, depth + 1, y);
        y += subtree.get(k) + verticalGap;
      });

      const first = kids[0].getBoundingClientRect();
      const last  = kids[kids.length - 1].getBoundingClientRect();

      centerY =
        (first.top + first.height / 2 +
         last.top + last.height / 2) / 2;
    }

    node.style.left = depth * levelGap + 150 + "px";
    node.style.top  = centerY - nodeH / 2 + "px";
  }

  roots.forEach(r => {
    place(r, 0, cursorY);
    cursorY += subtree.get(r) + verticalGap * 2;
  });

  // ðŸ”“ Restore transform
  world.style.transform = prevTransform;

  // ðŸ”¥ Recalculate edges from new node positions
  resetTransform()
  redraw();
  applyTransform()
}


function removeLastConnection() {
  if (edges.length === 0) return;

  edges.pop();          // remove most recent connection
  clearSelection();     // safety
  resetTransform()
  redraw();
  applyTransform()  // horizontalTreeLayout();
}

</script>

<!-- PNG export lib -->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

</body>
</html>
